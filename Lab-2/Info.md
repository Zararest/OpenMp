# Теоретические сведения
## Условия Бернстайна
Пусть в программе имеются два оператора S1 и S2,
непосредственно динамически следующих друг за другом. Пусть
W(S) – набор выходных переменных оператора S, а R(S) – набор его
входных переменных. Тогда возможность их одновременного
выполнения различными исполнителями в параллельной системе
можно определить с помощью условий Бернстайна.
Если для операторов S1 и S2, непосредственно
динамически следующих друг за другом, выполнено:
 - пересечение W(S1) и W(S2) пусто;
 - пересечение W(S1) и R(S2) пусто;
 - пересечение R(S1) и W(S2) пусто;
то они могут быть исполнены параллельно.

## Зависимости в циклах
```cpp
for (int i=0; i < i_fin; ++i) {
  S1: A[f(i)] = 
  S2: ... = A[g(i)]...
}
```

- S1 - запись
- S2 - чтение

Пусть:
$$
1 <= \lambda <= i_{fin}
$$

$$
1 <= \kappa <= i_{fin} 
$$

$$
f(\lambda) == g(\kappa)
$$

Тогда оюозначим:

$$
D = \lambda - \kappa
$$

- S1 - source
- S2 - sink
- D - расстояние зависимости цикла

Типы зависимостей:
- $D < 0$ - антизависимость (read after write)
- $D > 0$ - потоковая зависимость (write after read)

# Задания к допуску
## Вариант
Необходимо сделать 1г, 2г, 3г

## Векторы направлений и расстояний
`1г MPI`:
```cpp
for (i = 3; i < ISIZE; i++)
  for (j = 0; j < JSIZE - 2; j++)
    a[i][j] = sin(3 * a[i - 3][j + 2]);
```
Вектор функции источника и стока соответственно:
$$
F =
\begin{pmatrix}
  i \\
  j
\end{pmatrix}

G =
\begin{pmatrix}
  i' - 3 \\
  j' + 2
\end{pmatrix}
$$

Вектор расстояний:
$$
D = 
\begin{pmatrix}
  3 \\
  -2
\end{pmatrix}
$$

Вектор направлений:
$$
d = 
\begin{pmatrix}
  < \\
  >
\end{pmatrix}
$$

Тип - антизависимость

В данном векторе направлений нету зависимости =, поэтому распараллеливание придется проводить с ограничениями.

По внешнему циклу зависимость прямая. По внутреннему анти.

Если убрать слип в операции, то не получится получить ускорение из-за того что вычисление синуса быстрее чем копирование.

Результаты были померены со слипом 1ms.

100x100:
```
1 10495
2 5154
3 3534
4 2656
```

`2г OpenMP`:
```cpp
for (i = 0; i < ISIZE - 3; i++)
  for (j = 2; j < JSIZE; j++)
    a[i][j] = sin(0.1 * a[i + 3][j - 2]);
```

Вектор расстояний:
$$
D = 
\begin{pmatrix}
  -3 \\
  2
\end{pmatrix}
$$

Вектор направлений:
$$
d = 
\begin{pmatrix}
  > \\
  <
\end{pmatrix}
$$

В данном случае есть истинная зависимость по данным.

Надо распараллелть внешний цикл и скопировать 3 линии после i.

`3г OpenMP`:

Достаточно просто поставить барьерную синхронизацию между циклами


```cpp
for (i = 0; i < ISIZE; i++)
  for (j = 0; j < JSIZE; j++)
    a[i][j] = sin(0.005 * a[i][j]);

for (i = 5; i < ISIZE; i++)
  for (j = 0; j < JSIZE - 2; j++)
    b[i][j] = a[i - 5][j + 2] * 1.5;
```


```cpp
// однопоточная обработка
for (i = ISIZE - 5; i < ISIZE; i++)
  for (j = 0; j < 2; j++)
    a[i][j] = sin(0.005 * a[i - 5][j + 2]);

// многопоточная
for (i = 5; i < ISIZE; i++)
  for (j = 0; j < JSIZE - 2; j++)
    b[i][j] =  a[i - 5][j + 2] * 1.5;
```
